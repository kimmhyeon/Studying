# Java의 동작 과정
> 1. java소스를 javac로 컴파일하여 class파일 생성  
> 2. 클래스로더가 컴파일된 파일을 런타임 데이터 영역으로 로드
> 3. 실행 엔진이 실행

# JVM
> 1. 메소드 영역 : 클래스, static변수, 인터페이스 등이 저장
> 2. 힙 영역 : new를 통해 생성된 객체와 배열의 인스턴스를 저장, 가비지 컬렉터는 힙 영역을 정리하며 메모리 확보
> 3. 스택 영역 : 메소드가 실행되면 스택 영역에 1개 생성
> 4. PC 레지스터 : 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장 (CPU 레지스터와 다름)
> 5. Native 메소드 스택 : 자바 외의 언어로 작성된 코드를 위한 메모리영역, JNI를 통해 사용

# static
> 클래스 변수  
> static으로 선언된 변수는 변수가 선언된 클래스의 모든 인스턴스가 공유하는 변수  
> 클래스 변수는 인스턴스 생성 이전에 메모리 공간에 존재  
> 인스턴스 간에 데이터 공유가 필요한 상황에서 클래스 변수를 선언한다.
> 
# 인터페이스
> 객체를 어떻게 구성해야 하는지 정리한 설계도  
> 다형성을 극대화 하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위해 인터페이스 사용  

# 인터페이스 vs 추상 클래스
> 추상클래스  
> - Is - A "~이다"   
> - 단일 상속만 가능
> - 모든 접근 제어자 사용 가능
> - 변수와 상수 선언 가능
> - 추상 메소드와 일반 메소드 선언 가능  
>
> 인터페이스  
> - has - A "~을 할 수 있다."  
> - 다중 구현이 가능
> - public 접근 제어자만 사용 가능
> - 상수만 선언 가능
> - 추상메소드만 선언 가능  
>
> 한개의 클래스만 상속 가능하기 때문에 추상클래스를 통해 클래스를 구분  
> 할 수 있는 기능들은 인터페이스를 통해 구현  

# Synchronized
> 여러 쓰레드가 하나의 자원을 이용하고자 할 때, 한 쓰레드가 해당 자원을 사용중인 경우, 데이터에 접근할 수 없도록 막는 키워드  
> 병렬상황에서 자원의 접근을 안전하게 하지만, 자원을 이용하지 않는 쓰레드는 락에 의한 병목현상이 발생  

# 싱글톤 (Singleton)
> 객체의 인스턴스가 오직 1개만 생성되는 패턴
``` Java
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {
        // 생성자를 외부에서 호출하지 못하게 private로 지정
    }

    public static Singleton getInstance() {
        return instance;
    }
}
```
> 장점
> - 메모리 낭비 방지
> - 이미 생성된 인스턴스를 활용하니 속도 측면에서도 이점  
> - 다른 클래스간 데이터 공유가 쉽다
> - 도메인 관점에서 인스턴스가 한 개만 존재하는 것을 보증하고 싶은 경우 사용  
>
> 단점
> - 싱글톤 객체의 역할이 커질경우 다른 객체간의 결함도가 높아져 객체지향 설계원칙에 어긋나게 된다. (개발 - 폐쇄 원칙)  
> - 객체를 수정할 경우 사이드 이펙트(원래의 목적과 다른 부작용) 발생 확률 증가  
> - 멀티 쓰레드 환경에선 동기화 처리 문제 발생  
